# 디자인 패턴

목표를 달성하기 위해 사용되는 '재사용 가능한 해결책'

## 애플리케이션 구조

MVC 패턴의 뷰/모델 의존성을 해결하기 위하여 MVP 패턴의 Presentor가 등장했으며, Presentor 와 View 의 1:1 의존성으로 인한 낮은 유지보수성/재사용성을 해결하기 위해 View와 1:n으로 사용이 가능한 ViewModel을 도입하게 되었다고 볼 수 있다.

### MVVM 패턴

- Model : 애플리케이션에서 사용되는 데이터가 관리되는 부분이다.
- ViewModel : 하나 이상의 View에 의해 참조되며, Model을 통하여 View가 사용할 데이터를 가공하고, 제공한다.
View를 참조하지 않는다.
- View : 사용자에게 보여지는 부분으로, 사용자와의 상호작용에 따라 ViewModel을 참조하여 작동한다.

플로우 : View의 입력이 Command 패턴에 따라 ViewModel에 전달되면 ViewModel은 Model로부터 데이터를 요청하고, 수신한 테이터를 가공해서 저장한다. 이 데이터는 View와 바인딩되어있기 때문에 자동으로 갱신된다.

UI와 비즈니스 로직을 분리할 수 있다. 데이터 처리를 View에서 하지 않아 사용자에게 원활한 사용 경험을 제공할 수 있다. 또 개발 측면에서도 UI와의 독립적인 테스트가 가능하며, 독립적으로 유지 보수, 확장이 가능하다는 장점이 있다. 그러나 러닝커브가 높고 설계가 복잡해지는 단점이 있다.

### MVC 패턴
- Model,View (액티비티가 뷰와 Controller의 모든 기능을 포함하는 경우도 있음)
- Controller :  모델과 뷰의 통신을 담당하는 객체로, 사용자의 Action 에 따라 Model 에 데이터 업데이트를 요청하거나, 모델의 업데이트에 따라 뷰의 업데이트를 요청

문제점 : View가 모델을 직접 참조한다. 이는 모델과 뷰의 상호 의존성을 높여 유지 보수가 힘들게 만든다.
또 Controller가 모델과 뷰를 직접 업데이트 하는 등 SRP 원칙의 위배가 발생하기도 한다.
 View의 변경에 따른 Controller 변경이 빈번하고, Controller의 역할이 너무 커 애플리케이션의 성능이 떨어짐

### MVP 패턴
- Model,View
- Presentor : 뷰에서 보내온 이벤트에 따라 모델에 데이터를 요청하고, 받은 데이터를 가공하여 UI에 전달

전체적으로 MVC 패턴과 유사하지만 뷰는 모델과 직접적으로 연결되지 않게 되었고 따라서 뷰 모델 의존성이 감소했다. 또, 뷰는 뷰 업데이트에 집중할 수 있어 앱 성능 향상을 가져왔으나, Presentor와 Model의 1:1 의존성으로 인해 재사용성이 감소했고, Presentor가 SRP를 위배하기 쉬운 것은 여전하다.
