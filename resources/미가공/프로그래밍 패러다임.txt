# 프로그래밍 패러다임

## 함수형 프로그래밍

순수 함수 - 부수 효과(외부 환경을 변화시키는 것)없이 동일한 입력에 동일한 출력을 반환하는 함수(결정론적 함수)
이 불변성에 기반하여 모듈화 수준 향상에 기여하며, *상태*가 존재하지 않기 때문에 thread-safe한 로직을 구현할 수 있다.

일급 객체 : 변수에 할당하고, 인자로 전달되며, 리턴될 수 있는 객체
Kotlin에서의 함수는 일급 객체 (코틀린은 함수형/객체지향형을 모두 지원하는 다중 패러다임 언어)

고차 함수 : 함수를 파라미터로 받기 | 함수를 리턴, 코틀린에서는 ::foo 로 일반 함수를 고차함수로 바꿔 전달/반환할 수 있다.
람다 함수 : 무명 함수로, 고차 함수이다. { } 안에 작성하여 무명 클래스 인스턴스가 생성되는 방식으로 작동한다. inline으로 선언한 함수에 전달하면 객체 생성 없이 실행할 수 있다
 - 일반 함수는 JVM이 inline화(함수 내용을 동일한 바이트코드로 바꿔 작성) 해준다


### 기타

리액티브 프로그래밍
데이터가 필요할 때 요청하는 것이 아닌 데이터의 발행자에게서 데이터를 수신해서 사용하는 것
발행자는 데이터 스트림을 전송하게 된다
Producer(데이터 발행) -> Intermediary(중간 연산자, 데이터 편집) -> Consumer(소비자)
Producer : Flow Builder
Intermediary : Operator ex) map,filter,onEach,count,zip 등등
Consumer : Collector


## 객체지향 프로그래밍

현실 세계에서 개체들이 동작하는 방식을 프로그래밍에 적용하여
객체를 생성한 뒤 역할을 부여하여 객체의 상호작용으로 문제를 해결하는 프로그래밍 패러다임
객체는 역할에서 핵심적인 개념과 기능을 추출한 **추상화**를 통해 그 역할을 수행한다.
데이터를 담당하는 프로퍼티와 데이터를 조작하는 메소드를 기반으로 객체를 중심에 두는 프로그래밍 패러다임이다

### 주요 특성

1. 추상화
객체화 하고자 하는 대상의 공통점을 추출하여 메소드와 프로퍼티로 나타낸다. 코드 내에서는 interface등으로 공통점을 묶게 된다.

2. 상속 (is a)
기존의 클래스를 재활용하여 새로운 클래스를 작성하는 것, 상위 클래스의 속성/기능을 재사용하거나 확장,수정하여 사용할 수 있다

3. 다형성
클래스의 기능이 여러 가지 형태로 적용되는 성질, 동일 목적을 가진다 해도 그 작동 방식은 다를 수 있음을 반영한다.
오버로딩(같은 이름의 메소드가 다른 구현을 가지도록), 오버라이딩(상위 개체의 구현을 받아 메소드 재정의)이 이 역할을 수행하며
상위 클래스 타입의 참조변수로 하위 클래스를 참조할 수 있는 것도 다형성을 활용하는 예시가 된다. 상위 인터페이스 클래스를 매개 변수로 전달하면
하위 클래스를 구분하지 않고도 공통적인 기능을 이용하는 다른 객체를 사용할 수 있게 된다.
DI를 생각하자, Interface로 구현한 객체를 주입받은 다른 객체는, 그 구현체가 바뀌어도 수정할 필요가 없다.

4. 캡슐화
서로 관련 있는 프로퍼티와 메소드를 하나의 캡슐로 만들어 **외부로부터 보호**한다.
이렇게 되면 내부 데이터를 외부로부터 보호하고, 메소드의 동작을 감출 수 있다.
접근 제어자와 getter/setter 구현을 통해 캡슐화를 구현한다.

### SOLID 원칙

1.Single Responsibility
클래스는 오직 하나의 책임(역할)만을 가져야 한다. 연관 없는 수정의 영향을 받지 않는다.

2.Open-Closed
클래스는 확장에 개방적이고, 변경에는 폐쇄적이어야 한다.
기능을 확장하기 위해서 기존 코드를 수정해야 하면 안 된다.
이를 위해서는 설계 단계에서 확장될 요소를 고려하여 모듈의 교집합에 추상/인터페이스 클래스가 위치해야 한다.

3. Li..리스코프 치환의 원칙
부모 객체는 동작의 문제 없이 자식 객체로 치환될 수 있어야 하낟.

4.Interface Segregation
필요한 인터페이스만 상속받아야 하며, 인터페이스는 하나의 모호한 인터페이스보다 여러 개의 구체적 인터페이스가 낫다.

5.Dependency Inversion
상위 레벨(더 추상적인 것)은 하위 레벨(더 구체적인 것)에 의존하지 않아야 한다, 추상적인 것에 의존하여야 한다.
ex) 자동차는 엔진의 구현체에 관계 없이 Engine 추상 클래스에 의존해서 구현하였다.
- 원래 인터페이스는 클래스에 의존했다. 그러나 설계에서는 이것은 역전됨!

### Abstract VS Interface

#### Abstract Class

클래스 간의 상속 관계에서 공통된 **속성**을 추상화하여 묶는데 쓰이는 클래스이다
상속받는 자식 클래스들은 abstract method들을 구현하여야 한다
**메소드와 상수, 생성자, 일반 함수**등 클래스의 내용을 모두 담을 수 있다.


#### Interface

특정 **기능**을 구현해야 하는 클래스들에게 메소드 생성을 강제한다.
abstract class와는 다르게 콤마로 구분하여 다중 상속이 가능하며, 
**메소드와 상수**로 구성된다