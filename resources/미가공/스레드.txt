# 스레드 작업

스레드는 *실행의 가장 작은 단위*이다
안드로이드에서는 보통 싱글 스레드인 메인 스레드가 워커 스레드를 사용하여 DB/네트워크 등의 오래 걸리는 작업을 처리하고, 그 결과를 보고받아 UI를 업데이트하는 식으로 작동한다
이 때 Message(작업 정보)와 Runnable(실행 동작)을 전달하는 게이트웨이로 사용하는 것이 Handler이다.

메인 스레드는 핸들러를 생성하고, 워커 스레드를 생성한 뒤 핸들러를 전달하게 된다
워커 스레드는 핸들러를 보관하고, 생성할 때 정의된 작업을 실행한뒤,작업 결과를 Message에 저장한다
 - 이 때 Message 객체를 새로 생성하는 것이 아닌, Handler.obtainMessage()나 Message.obtain() 으로 재활용한다
작성한 메시지를 **메인 스레드**의 핸들러를 통하여 sendMessage(message) 하면 이 메시지는 메인 스레드 Looper 속 MessageQueue로 들어간다
Looper는 MessageQueue를 까면서 Runnable이면 실행해주고(이미 실행내용 포함), Message이면 Handler.handleMessage()(직접 구현)로 처리해준다

## Looper

스레드가 한 개씩 가질 수 있는(메인 스레드 이외에서는 prepare(),loop() 호출해야 생성되고 일함) 메시지 처리기이다.
Looper는 핸들러가 messeageQueue에 넣어놓은 Message/Runnable을 까면서 
Message이면 handler.handleMessage(message) 해주고, Runnable 이면 handler.post(runnable) 해 준다

## Handler

스레드간 중간다리라고 할 수 있다. 스레드를 생성할 때 핸들러를 함께 넘겨주게 되는데(전역적으로 공유도 가능), 스레드는 할당받은 Runnable을 실행하고 나서
그 결과를 message.setData(Bundle("key","value"))) handler.sendMessage(message)로 전달하거나 handler.post(runnable)로 전달한다
: 핸들러 이렇게 전달하다보면 결합도가 올라간다. 

Tip: 러너블 특) 인터페이스임 스레드는 클래스임

커널 영역 == 프로세서 메모리 - 유저 영역
스레드는 스택을 분리하고 힙/코드/데이터 영역 공유 각영역엔 뭐있지
프로세스는 이제 스레드 박스라고 볼 수 있음

## 스레드 풀

동시성 작업을 돕기 위한 스레드이지만 과도하게 생성되면 메모리가 낭비되고 스케쥴러가 작업을 배분하는 오버헤드가 커진다.
따라서 안드로이드는 스레드 풀에 일정 개수의 스레드를 유지하면서, 스레드 생성 비용을 아끼면서 과도한 스레드의 생성을 막는다
자바의 `ExecutorService`인터페이스와 `Executors`클래스를 사용하면 다운로드, 여러 네트워크 처리 등 멀티스레드 작업이 필요할 때 스레드 풀을 생성할 수 있다.
Executors 클래스의 `newCachedThreadPool()` 은 최대 개수 제한이 없지만 1분동안 작업하지 않으면 스레드를 삭제하는 스레드 풀을 생성하고
`newFixedThreadPool(nThreads:Int)`는 일단 제한 내 개수의 스레드를 생성하면 스레드를 삭제하지 않는다
스레드 풀의 스레드는 데몬 스레드(메인 스레드를 보조하며 함께 종료되는 스레드)가 아니므로 메인 스레드 종료와 함께 스레드 풀의 종료가 필요하다

### 코틀린에서의 멀티스레드 작업

UI 스레드에서 thread(start=true){}로 내용을 작성해 주면 스레드를 시작할 수 있다. 
심지어 저 람다 내에서 runOnUiThread{}하면 메인스레드 작업도 실행 됨

근데 코루틴 쓰자! 코루틴! 가볍다! 빠르다!
병렬 처리가 진짜 필요한 경우 : 이미지 작업, 다운로드 스레드 여러 개 등등 수많은 작업을 동시에 병렬적으로 해야 할 경우

## 코루틴
코루틴은 힙 영역에 저장된 자체 stack을 가지지 않는 작업 객체이다.(문맥 교환이 없는 이유!) 코루틴이라는 추상적 흐름은 Job 인터페이스를 상속받아 표현된다.
코루틴에 suspend 함수를 맡기면, Continuation Passing Style을 구현하기 위하여 `continuation` 이라는 작업의 진행상황을 StateMachine으로 저장한다.
이 StateMachine에는 각 변수가 null 로 선언되어 있고, 작업의 진행도를 나타내는 Label:Int, result:Any? 두 변수를 선언하게 된다.
이제 when(label){}로 작업 내용을 여러 단위로 쪼개어 작성하고, continuation:StateMachine(실제로는 completion:Cotinuation<Any?>의 캐스팅이다)에 대해
continuation.label을 변화시켜 작업 단계를 조정하고, 작업의 결과인 continuation.result을 변수인 contuation.bar로 캐스팅해 저장하며 작업을 진행한다
when문의 마지막 라벨에서 completion.resume(continuation.returnBar)을 호출해 결과를 반환하게 된다.
스택만을 독립해 가지며 heap을 공유해 멀티프로세스보다 빠른 작업을 수행했던 멀티스레드에 이어, 코루틴은 suspend 함수로 `협력성`을 지니게 된 것이다.
suspend가 함수를 쪼갠다면 코루틴 빌더(launch,async,runBlocking) Dispatchers의 도움으로 함수를 다른 스레드에 배정한다고 볼 수 있다.
그래서 만약 unsuspended 함수를 코루틴으로 빌드하면 그 함수는 배정된 스레드에서 blocking으로 실행된다 : 만약 지연작업이 있을 경우 다른 스레드가 빌더 내의 작업을 맡게 됨!

내가 좋아하는 비유 한 번 해보자면, 

안드로이드 디바이스라는 기업은 특정 일을 수행해야 합니다. 일을 수행하기 위해서 프로세서라는 공장을 건설했습니다.
프로세서는 여러 가지 물건을 만들 수 있었지만, 한 번 공장이 돌아갈 때 만들어낼 수 있는 물건은 한 종류 뿐이었기 때문에, 기업은 여러 공장을 건설해서 여러 종류의 물건을 동시에 만들기 시작합니다(멀티프로세서의 도입)
이 여러 공장들은 물건을 만드는 과정을 서로 분업하거나, 서로 다른 물건을 만들 수 있었지만, 만드는 물건을 바꾸려면 생산 설비를 교체(문맥 교환)해야 하기 때문에 한 공장에 여러 생산 로봇(스레드)을 도입하는 것을 고려했습니다.
생산 로봇은 정해진 프로그램에 따라 열심히 물건을 만들었으나, 로봇끼리 협력적으로, 효율적으로 프로그램을 작성하는 것은 힘들었습니다. 프로그램 교체도 설비 교체보다는 아니지만 시간이 걸렸죠(스레드의 문맥 교환) 그래서 추가된 것이 `공유 분업 프로그램`(코루틴)입니다.
`공유 분업 프로그램`은 내용과 진행도를 자동으로 기록하는, 작업이 분할된 프로그램입니다. 공장 관리자(스케쥴러)는 `공유 분업 프로그램`으로 작성된 여러 일들을 놀고 있는 로봇들에게 분배했고, 마침내 효율적인 생산이 시작되었습니다.

전공자용 설명
프로세서에 적재된 상태의 프로그램을 프로세스라고 부르는 것을 알고 있을것이다. 여러 프로세스를 한 번에 돌리는 동시성과 병렬성을 확보하기 위해서 멀티프로세서의 개념이 도입되었고,(이전에는 문맥 전환으로 동시성만을 취할 수 있었음) 
프로세스 간 전환이 무거운 문제를 해결하고, 한 프로세스 내에서의 동시성을 강화하기 위해서 프로세서에 스레드 개념을 도입했다(스택 이외의 공간을 공유하는 실행의 흐름)
이후 프로세스 내 작업을 `힙 공간에 저장된 일시중단되어 여러 스레드가 협력할 수 있는 작업`인 코루틴을 단위로 작업이 수행되게 되었다.
(주의 : 프로세서는 하드웨어 개념, 프로세스,스레드는 소프트웨어 개념이다 - 소프트웨어는 운영체제가 관리)
