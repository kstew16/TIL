# 컴포즈

제트팩 컴포즈는 UI의 트리 구조로 사용되던 기존의 방식에서 선언형 패러다임을 도입한 방식이다
Jetpack Compose는 UI 업데이트에서 상위 Composable에서 하위 Composable로 데이터가 흐르는 형식으로 작동하는데,
이 흐름에 따라 다른 인수로 Compose 함수가 다시 호출되어 UI를 업데이트한다 -> ViewModel등에 데이터를 제공하기가 더 수월해짐
반대로 사용자가 상호작용하면 이벤트가 Composable을 위로 거슬러 올라가며 필요한 Composable을 재호출 (원래는 UI요소에 대한 setter가 작동했어!)


Composable
순서없이/동시에/애니메이션에서는 프레임 빈도로 실행되는
최대한 적게(필요없는 애들은 재구성에서 건너뜀)/낙관적이며 취소될 수 있는 재구성을 가진 함수

컴포저블은 remember API 를 사용하여 메모리에 객체를 저장하고, 상태로 사용한다. 변경시 리컴포지션!
rememberSavable : 화면 회전 등 재구성에 보존되어야 할 값을 기억하고 유지하는데 사용 Parcelize!
Flow -> collectAsState//LiveData -> ObserveAsState

상태를 가지지 않는 컴포저블에게 상위 컴포저블이 데이터를 전달하며, onValueChanged 람다를 전달해주는 등 상태 호이스팅(끌어올리기)
를 사용할 수 있다 ->  상태의 저장 방식과 표현 방식이 분리되어 재사용성이 증가한다! 캡슐화, 인터셉팅도 가능

컴포즈 수명 주기
초기 호출 -> 상태 변경에 따라 리컴포지션 예약 (0~n회 반복) -> 종료
컴포저블 인스턴스는 소스 코드 위치에 따라 **식별** 되며, 같은 위치에서 여러 번 호출되면 실행 순서가 식별 도구로 추가 지원
key(id)컴포저블을 사용해 또 다른 식별 도구를 제공할 수도 있음(Column같은데에 중복데이터 차단하는데 사용 가능)

프레임 렌더링 과정 : 컴포지션(표시 항목 결정)-레이아웃(layout+modifier)-그리기 : 상태가 변경되면 그리기만 호출